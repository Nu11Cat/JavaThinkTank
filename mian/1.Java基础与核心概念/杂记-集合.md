## 为什么数组的索引从0开始？

数组的索引从0开始是和内存寻址方式相关的。在底层，数组是一块连续内存，访问第i个元素的时候，通过寻址公式“起始地址+i*元素大小”。如果从1开始，访问时需要额外减法，增加cpu的计算负担。

而且在性能之外，这种设计也让数组在算法设计上更简洁。在处理比如区间，切片这样的问题的时候，符合我们常用的左闭右开的区间表达方式，能减少 off-by-one（差一错误）。

## 数组和集合的区别

| 特性         | 数组（Array）                | 集合（Collection）                                         |
| ------------ | ---------------------------- | ---------------------------------------------------------- |
| **大小**     | 固定大小                     | 动态大小                                                   |
| **类型**     | 相同类型的元素               | 支持泛型，允许不同类型元素                                 |
| **操作**     | 只能按索引访问，无法增删元素 | 提供增删查找操作，灵活性强                                 |
| **性能**     | 访问速度快，操作受限         | 访问速度较慢，但提供更多功能                               |
| **元素顺序** | 保持插入顺序                 | 顺序取决于集合类型（如 `List` 保持顺序，`Set` 不保证顺序） |
| **内存管理** | 连续内存分配                 | 内存分配不连续，管理复杂                                   |
| **支持泛型** | 不支持泛型                   | 支持泛型，类型安全                                         |

## 数组和集合的相互转化

通过Array.asList可以把数组转化为集合，但是是浅拷贝，当数组的元素改变，集合也会改变。

因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合,在这个集合的构造器中,把我们传入的这个集合进行了包装而已,最终指向的都是同一个内存地址。

通过list.toArray可以把集合转化为数组，是深拷贝，在底层进行了数组的拷贝。